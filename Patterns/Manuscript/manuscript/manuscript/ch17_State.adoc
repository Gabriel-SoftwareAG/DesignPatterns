
= Chapter 17: The State Pattern

:imagesdir: ../images/ch17_State

== Introduction

[cols="2", frame="none", grid="none"]
|===
|Imagine you have a traffic light at an intersection. It can be in one of three states: red, yellow, or green. Each state represents a different behavior for the traffic light: red means stop, yellow means prepare to stop, and green means go.

In software design, the state pattern works similarly. It allows an object to change its behavior when its internal state changes. Just like how the behavior of the traffic light changes depending on its current state, objects in a software application can behave differently based on their current state.

|image:state_traffic_light.jpg[width=300, scale=50%]
|===

Here is another another example. let's say you're building a vending machine. It can be in different states: idle, waiting for selection, dispensing, or out of stock. Each state corresponds to a different behavior: idle means it's ready for use, waiting for selection means it's waiting for the user to make a choice, dispensing means it's giving out the selected item, and out of stock means it can't fulfill any requests.

Using the state pattern, you can encapsulate each state and its corresponding behavior in separate objects. When the state of the vending machine changes, it switches to the appropriate state object, which determines how it should behave in that state.

Overall, the state pattern provides a way to model objects that can change their behavior dynamically based on their internal state, similar to how a traffic light changes its behavior depending on its current state.

== Key Components

- _Context_: The Context represents the object whose behavior can change dynamically based on its internal state. In the traffic light analogy, the traffic light itself serves as the Context, while in the vending machine example, the vending machine is the Context.
- _State_: The State interface defines a common interface for all concrete state classes, encapsulating the behavior associated with a particular state. For instance, in the traffic light scenario, the State interface defines methods like `stop()`, `prepareToStop()`, and `go()`, implemented by concrete state classes like `RedState`, `YellowState`, and `GreenState`. Similarly, in the vending machine example, the State interface would define methods like `selectItem()`, `dispenseItem()`, etc.
- _Concrete State_: Concrete State classes implement the State interface and encapsulate the behavior associated with a specific state of the Context. For instance, the `RedState`, `YellowState`, and `GreenState` classes in the traffic light analogy, and `IdleState`, `SelectionState`, `DispensingState`, and `OutOfStockState` classes in the vending machine example.


== UML Diagrams 
Next, we will explain the concept of the State design pattern using UML.

=== Class Diagram
image::StatePatternClassDiagram.png[title="The State Class Diagram", align=center]
The diagram illustrates the State design pattern using a traffic light analogy. The Context class represents the traffic light, which has a state attribute representing its current state. Analogous to the traffic light, the Context class can setState(state: State) to change its behavior and request() to trigger actions based on its current state. The State interface acts as the blueprint for different states of the traffic light, defining a handle() method. Concrete state classes such as ConcreteStateA and ConcreteStateB correspond to different states of the traffic light, such as red, yellow, and green. Each concrete state class implements the handle() method, specifying the behavior of the traffic light in that state. Through this design, the traffic light can dynamically change its behavior based on its internal state, just like how objects in software applications can change their behavior based on their state.

=== Sequence Diagram
image::StatePatternSequenceDiagram.png[title="The State Sequence Diagram", align=center]
This sequence diagram illustrates the State design pattern in action, akin to how a traffic light operates. Here, the "Client" can be thought of as a driver at an intersection, making a request to the traffic light system (the "Context") to change its state. The "Context" represents the traffic light control system itself, which manages the current state of the traffic light. The "State" interface is analogous to the general concept of a traffic light state, with methods that define actions like changing from green to red. "ConcreteStateA" and "ConcreteStateB" represent specific states of the traffic light, such as green and red, respectively. Initially, the traffic light is in "ConcreteStateA" (green), allowing traffic to move. Upon a request (perhaps a timer signaling change), the control system invokes the handle method on the current state, which performs an action (like transitioning from green to yellow) and notifies the control system to switch to "ConcreteStateB" (red), halting traffic flow. This process exemplifies how the State design pattern allows an object (the traffic light system) to change its behavior dynamically by switching between different states (green, yellow, red) in response to external interactions (the passage of time or a manual switch).

== Implementation Walkthrough

This example demonstrates implementing a simple traffic light system (red, green, and yellow) where the traffic light changes its state in response to a timer event, akin to real-world traffic light operations.

=== Overview

In our analogy:
- *Client* represents external factors or systems interacting with the traffic light, such as a timer or sensor.
- *Context* (TrafficLight) acts as the traffic light control system, managing the current state of the light.
- *State* interface declares common operations for all concrete states.
- *Concrete States* (GreenState, YellowState, RedState) represent specific states of the traffic light, each with distinct behavior.

=== State Interface

[source,java]
----
public interface State {
    void handleRequest();
}
----

This interface defines the `handleRequest()` method, which is implemented by all concrete state classes. It represents an action that occurs when transitioning from one state to another, such as changing the light from green to yellow.


=== GreenState

[source,java]
----
public class GreenState implements State {
    public void handleRequest() {
        System.out.println("Green light - Go!");
        // Logic to switch to the yellow light
    }
}
----

`GreenState` indicates the traffic light is green. The `handleRequest()` method would contain logic to transition to `YellowState`.

=== YellowState

[source,java]
----
public class YellowState implements State {
    public void handleRequest() {
        System.out.println("Yellow light - Caution!");
        // Logic to switch to the red light
    }
}
----

`YellowState` signals caution. The method implementation here transitions the light to red.

=== RedState

[source,java]
----
public class RedState implements State {
    public void handleRequest() {
        System.out.println("Red light - Stop!");
        // Logic to switch to the green light
    }
}
----

In `RedState`, the traffic must stop. The `handleRequest()` method would switch the state back to `GreenState`, completing the cycle.

=== Context (TrafficLight)

The `TrafficLight` class uses State objects to change its current state based on external interactions, such as the passage of time.

[source,java]
----
public class TrafficLight {
    private State currentState;

    public TrafficLight(State state) {
        this.currentState = state;
    }

    public void change() {
        currentState.handleRequest();
        // Logic to change the current state
    }

    public void setState(State state) {
        this.currentState = state;
    }
}
----

`TrafficLight` starts with an initial state and changes it through the `change()` method. The `setState()` method updates the current state.

=== Client Usage

[source,java]
----
public class TrafficSystem {
    public static void main(String[] args) {
        TrafficLight light = new TrafficLight(new GreenState());

        light.change(); // Green to Yellow
        light.setState(new YellowState());

        light.change(); // Yellow to Red
        light.setState(new RedState());

        light.change(); // Red to Green
    }
}
----

The `TrafficSystem` class simulates the traffic light system's operation, transitioning through green, yellow, and red states, showcasing how the State design pattern facilitates state management in a straightforward and flexible manner.


== Design Considerations

When implementing the State design pattern, several key design considerations should be taken into account to ensure the pattern is applied effectively and efficiently:

. *Encapsulation of State-specific Behavior*: Each state should encapsulate behavior that is specific to that state. This ensures that the context class remains simple and focused on state management, rather than being cluttered with state-specific logic.

. *State Transitions*: Consider who is responsible for triggering state transitions. While the context class can control transitions based on external inputs, states themselves can also trigger transitions after completing their specific behavior. This can lead to more decentralized and dynamic state management.

. *State Object Lifecycle*: Decide whether state objects should be created anew each time a state transition occurs or if a single, reusable instance of each state class should be maintained. Using single instances (the Flyweight pattern) can reduce memory usage and object creation overhead.

. *Adding New States*: The design should be flexible enough to allow the addition of new states without significant modifications to existing code. This can be achieved by ensuring that states and the context class depend on abstractions rather than concrete classes.

. *Context and State Interaction*: Determine how much information the state objects need about the context. While back references (state objects holding a reference to the context) can increase flexibility and allow states to control transitions, they also couple the state and context more tightly.

. *Separation of Concerns*: Keep the state logic separate from the context logic. The context should focus on managing the current state and delegating state-specific behavior to the state objects, while the state objects should focus solely on the behavior specific to that state.

By carefully considering these aspects, developers can leverage the State design pattern to create flexible and maintainable systems that can dynamically change their behavior based on internal states.


== Conclusion

The State design pattern offers a robust framework for managing state-dependent behavior within software applications. By encapsulating state-specific logic in separate classes and delegating behavior to the current state object, this pattern promotes high cohesion and low coupling, aligning well with the principles of object-oriented design. Its application can significantly simplify the codebase of complex systems that require dynamic behavior changes in response to internal state transitions, such as user interfaces, game development, and workflow management systems.

Moreover, the State pattern enhances maintainability and scalability by making it easier to add new states or modify existing behaviors without extensive modifications to the core system. It also facilitates a clearer separation of concerns, as state management logic is neatly abstracted away from the business logic.

However, like any design pattern, the State pattern comes with its considerations. Designers must carefully plan how state transitions are initiated and managed, decide on the lifecycle of state objects, and ensure that the system's architecture supports the flexibility and dynamic behavior that the pattern brings.

In conclusion, when used judiciously, the State design pattern can lead to cleaner, more organized code that is easier to extend and maintain. It is a powerful tool in the software developer's toolkit, offering a structured approach to handling complexity and variability in object behavior.
