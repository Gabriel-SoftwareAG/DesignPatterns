
= Chapter 12: The Decorator Pattern

:imagesdir: ../images/ch12_Decorator

== Introduction

[cols="2", frame="none", grid="none"]
|===
|Let's say you have a plain cheese pizza. It's delicious on its own, but you want to add some extra flavor to it. Instead of ordering multiple different pizzas, you can use the decorator pattern to customize your pizza with various toppings.

You start with the plain cheese pizza as your base. Then, you add pepperoni as a decorator to give it a savory and slightly spicy flavor. Next, you sprinkle some mushrooms as another decorator to add a rich and earthy taste. Additionally, you include bell peppers as another decorator to add a sweet and crunchy texture. Finally, you drizzle some barbecue sauce as a final decorator to add a tangy and smoky finish.  
|image:decorator_pizza.jpg[width=300, scale=50%]
|===

Each decorator enhances the flavor profile of the pizza without changing its fundamental nature. You can mix and match toppings based on your preferences, creating a customized pizza that suits your taste buds. Just like adding layers of decoration to a cake or features to a smartphone, the decorator pattern allows you to enhance and customize objects dynamically, making them more delicious and satisfying.

== Key Components

- _Component_: The component represents the base object to which decorators are added. In our analogy, the plain cheese pizza serves as the component.
- _Decorator_: Decorators are additional layers that enhance the functionality or behavior of the component without altering its core structure. In our example, pepperoni, mushrooms, bell peppers, and barbecue sauce serve as decorators, adding various toppings to customize the flavor of the pizza.
- _Concrete Component_: The concrete component is the actual implementation of the component interface. In our analogy, the plain cheese pizza is the concrete component that implements the base pizza functionality.
- _Concrete Decorator_: Concrete decorators are the specific implementations of decorators that add functionality to the component. In our example, each topping (pepperoni, mushrooms, bell peppers, and barbecue sauce) is a concrete decorator that adds a unique flavor or texture to the pizza.


== UML Diagrams 
Next, we will explain the concept of the Decorator design pattern using UML.

=== Class Diagram
image::DecoratorPatternClassDiagram.png[title="The Decorator Class Diagram", align=center]
In this diagram, let's interpret the Decorator Pattern using the analogy of customizing a pizza. The "Component" interface represents the base pizza, defining the operation of the pizza, such as baking. The "ConcreteComponent" class is the concrete implementation of the pizza, representing the plain cheese pizza. The "Decorator" abstract class serves as the base decorator, which adds toppings to the pizza. It contains a reference to the base pizza component. "ConcreteDecoratorA" and "ConcreteDecoratorB" are concrete decorators that add specific toppings to the pizza, such as pepperoni and mushrooms. Each concrete decorator extends the decorator class and adds its unique behavior, such as adding pepperoni slices or mushroom slices to the pizza. Overall, the Decorator Pattern allows for dynamic customization of objects by adding multiple layers of decorators, similar to customizing a pizza with various toppings.

=== Sequence Diagram
image::DecoratorPatternSequenceDiagram.png[title="The Decorator Sequence Diagram"]
In this sequence diagram, let's interpret the Decorator Pattern using the analogy of customizing a pizza. The "Client" represents the entity (e.g., a customer or a chef) interacting with the pizza customization process. The "Component" is the base pizza, representing the core functionality of the pizza, such as its dough and cheese. The "ConcreteComponent" is the concrete implementation of the base pizza, representing the plain cheese pizza. "DecoratorA" and "DecoratorB" are decorators that add additional toppings or behaviors to the pizza. For example, DecoratorA could represent adding pepperoni, while DecoratorB could represent adding mushrooms. Each decorator enhances the pizza's functionality by adding specific toppings or behaviors. The sequence of interactions shows how the decorators are applied to the base pizza to customize it with additional toppings, resulting in the final customized pizza being returned to the client. Overall, the Decorator Pattern allows for dynamic customization of objects by adding multiple layers of decorators, similar to customizing a pizza with various toppings.

== Implementation Walkthrough

In this example, we'll implement the Decorator Pattern in Java using the analogy of customizing a pizza with various toppings. We'll have four main classes: `Pizza` (Component), `PlainCheesePizza` (ConcreteComponent), `PizzaDecorator` (Decorator), and concrete decorators such as `PepperoniDecorator` and `MushroomDecorator`. The `Pizza` class represents the base pizza, while the decorators represent toppings that can be added to the pizza dynamically.

=== Pizza (Component) Interface

[source,java]
----
public interface Pizza {
    void bake();
}
----

The `Pizza` interface defines the base pizza functionality.

=== PlainCheesePizza (ConcreteComponent) Class

[source,java]
----
public class PlainCheesePizza implements Pizza {
    public void bake() {
        System.out.println("Baking plain cheese pizza");
    }
}
----

The `PlainCheesePizza` class is the concrete implementation of the `Pizza` interface, representing the plain cheese pizza.

=== PizzaDecorator (Decorator) Abstract Class

[source,java]
----
public abstract class PizzaDecorator implements Pizza {
    protected Pizza pizza;

    public PizzaDecorator(Pizza pizza) {
        this.pizza = pizza;
    }

    public void bake() {
        pizza.bake();
    }
}
----

The `PizzaDecorator` abstract class serves as the base decorator, implementing the `Pizza` interface and holding a reference to the base pizza component.

=== PepperoniDecorator and MushroomDecorator (Concrete Decorators) Classes

[source,java]
----
public class PepperoniDecorator extends PizzaDecorator {
    public PepperoniDecorator(Pizza pizza) {
        super(pizza);
    }

    public void bake() {
        super.bake();
        System.out.println("Adding pepperoni");
    }
}

public class MushroomDecorator extends PizzaDecorator {
    public MushroomDecorator(Pizza pizza) {
        super(pizza);
    }

    public void bake() {
        super.bake();
        System.out.println("Adding mushrooms");
    }
}
----

The `PepperoniDecorator` and `MushroomDecorator` classes are concrete implementations of the `PizzaDecorator` abstract class. They add pepperoni and mushrooms, respectively, to the pizza.

=== Usage Example

Now, let's see how the classes are used together:

[source,java]
----
public class Main {
    public static void main(String[] args) {
        Pizza plainCheesePizza = new PlainCheesePizza();
        
        // Adding pepperoni to the pizza
        Pizza pepperoniPizza = new PepperoniDecorator(plainCheesePizza);
        pepperoniPizza.bake();
        
        // Adding mushrooms to the pizza
        Pizza mushroomPizza = new MushroomDecorator(plainCheesePizza);
        mushroomPizza.bake();
        
        // Adding both pepperoni and mushrooms to the pizza
        Pizza deluxePizza = new MushroomDecorator(new PepperoniDecorator(plainCheesePizza));
        deluxePizza.bake();
    }
}
----

In this example, we create a `PlainCheesePizza` object representing the base pizza. We then use decorators to add pepperoni, mushrooms, or both toppings to customize the pizza. Each decorator dynamically adds the specified topping to the base pizza, resulting in a customized pizza with the desired toppings.


== Design Considerations

When implementing the Decorator Pattern in software development, several design considerations should be taken into account:

* **Separation of Concerns**: Ensure that the base component (pizza) and decorators (toppings) each have a single responsibility and are not tightly coupled. This promotes modularity and maintainability by allowing components to be added, removed, or modified independently.
* **Flexibility and Extensibility**: Design the decorators to be easily extendable to accommodate new toppings or behaviors. This allows for dynamic customization of objects at runtime without modifying existing code, promoting flexibility and extensibility in the system design.
* **Order of Decorators**: Consider the order in which decorators are applied to ensure the desired behavior is achieved. Depending on the application requirements, decorators can be applied in different orders to produce different results.
* **Performance Overhead**: Be mindful of the performance overhead introduced by multiple layers of decorators, especially in scenarios where a large number of decorators are applied to objects. Minimize unnecessary overhead by keeping decorators lightweight and efficient.
* **Error Handling**: Implement robust error-handling mechanisms in decorators to handle unexpected scenarios gracefully. Ensure that errors are handled transparently to the client, maintaining system reliability and user satisfaction.


== Conclusion

The Decorator Pattern is a powerful design pattern for dynamically customizing objects at runtime, as demonstrated in our implementation walkthrough example with customizing pizzas. By allowing objects to be extended with multiple layers of decorators, the pattern promotes flexibility, maintainability, and reusability in software design. Decorators can be added, removed, or modified independently, enabling dynamic customization of objects without altering their core structure. This approach enhances the scalability and extensibility of software systems, allowing for easy adaptation to changing requirements and preferences. Overall, the Decorator Pattern is a valuable tool for enhancing the functionality and versatility of objects in object-oriented programming.
