= Command Design Pattern

:imagesdir: ../images/ch15_Command

== Introduction

[cols="2", frame="none", grid="none"]
|===
|The Command Design Pattern is a behavioral design pattern that turns a request into a stand-alone object. This allows request parameters to be saved, queued, and executed at different times according to the application's needs. Imagine you're at a restaurant. You (the `Client`) give your order (`Command`) to a waiter (`Invoker`), who then delivers the order to the kitchen (`Receiver`). The kitchen prepares your meal and eventually, the waiter delivers the meal back to you. In this analogy, your order is encapsulated as a command and handled independently of the initial request.
|image:command_kitchen.jpg[width=280, scale=50%]
|===

== Key Components

- _Client_: Represents the entity that initiates requests or commands. In the restaurant analogy, the client corresponds to the customer who places an order.
- _Command_: Encapsulates a request as an object, allowing it to be parameterized and passed as an argument. In the restaurant scenario, the command represents the customer's order, which contains details of the requested meal.
- _Invoker_: Sends commands to execute requests, but it doesn't know how the request is handled. It acts as an intermediary between the client and the receiver. In the restaurant context, the invoker is akin to the waiter who takes the customer's order and relays it to the kitchen.
- _Receiver_: Handles the request specified by the command. It knows how to perform the action associated with the command. In the restaurant example, the receiver is the kitchen staff responsible for preparing the meal according to the order received.


== UML Diagrams 
Next, we will explain the concept of the Command design pattern using UML.

=== Class Diagram
image::CommandPatternClassDiagram.png[title="The Command Class Diagram"]
In this Command Pattern class diagram, we can relate the elements to roles in a restaurant scenario. The Command interface represents the order placed by a customer, which is abstracted as an executable command. ConcreteCommand classes, such as ConcreteCommandA and ConcreteCommandB, correspond to specific orders like "Prepare Pizza" or "Serve Pasta," each associated with a particular receiver, represented by the Receiver class. The Receiver class embodies the kitchen staff responsible for executing the commands by performing actions like actionA() or actionB(), which could be preparing specific dishes. The Invoker class acts as the waiter who takes orders from customers (Client) and relays them to the kitchen staff (Receiver) to execute (invokeCommand()). The Client class represents the entity initiating the commands, akin to a customer placing an order at the restaurant. Overall, the Command Pattern decouples the sender (Client) from the receiver (Receiver) by encapsulating requests as objects, providing flexibility and extensibility in handling commands.

=== Sequence Diagram
image::CommandPatternSequenceDiagram.png[title="The Command Sequence Diagram"]
In this Command Pattern sequence diagram, we can relate the interactions to a scenario in a restaurant. The Client represents a customer who places an order, specifying the command to be executed. This order is passed to the Invoker, who acts as the waiter taking the customer's request. The Invoker then triggers the execution of the command (executeCommand()), which is represented by the ConcreteCommand. In our analogy, the ConcreteCommand corresponds to a specific dish order, such as "Prepare Pizza" or "Serve Pasta." The ConcreteCommand delegates the actual execution of the command to the Receiver, symbolizing the kitchen staff responsible for preparing the meal. Once the action is completed, the Receiver notifies the ConcreteCommand, which then reports back to the Invoker that the execution is completed. Finally, the Invoker communicates the status back to the Client, informing them that their request has been fulfilled. This sequence illustrates how the Command Pattern facilitates decoupling between the sender (Client) and receiver (Receiver) by encapsulating requests as objects and enabling their execution at different times.

== Implementation Walkthrough

=== Command Interface

The `Command` interface represents an abstract command that can be executed. In our restaurant analogy, this interface defines a contract for any order that can be placed.

[source,java]
----
interface Command {
    void execute();
}
----

=== ConcreteCommand Classes

ConcreteCommand classes implement the `Command` interface and represent specific orders. Each ConcreteCommand corresponds to a particular dish or action that can be executed in the restaurant.

[source,java]
----
class PreparePizzaCommand implements Command {
    private Receiver receiver;

    PreparePizzaCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        receiver.preparePizza();
    }
}

class ServePastaCommand implements Command {
    private Receiver receiver;

    ServePastaCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        receiver.servePasta();
    }
}
----

=== Receiver Class

The `Receiver` class represents the entity responsible for carrying out the commands. In our restaurant analogy, the Receiver corresponds to the kitchen staff who execute the orders.

[source,java]
----
class Receiver {
    void preparePizza() {
        // Logic to prepare pizza
    }

    void servePasta() {
        // Logic to serve pasta
    }
}
----

=== Invoker Class

The `Invoker` class acts as an intermediary between the Client (customer) and the ConcreteCommand (order). It receives requests from the Client and invokes the corresponding ConcreteCommand to execute the order.

[source,java]
----
class Waiter {
    private Command command;

    void setCommand(Command command) {
        this.command = command;
    }

    void executeCommand() {
        command.execute();
    }
}
----

=== Client Class

The `Client` class represents the entity initiating the commands, in this case, the customer placing an order at the restaurant.

[source,java]
----
public class Customer {
    public static void main(String[] args) {
        // Create receiver (kitchen staff)
        Receiver chef = new Receiver();

        // Create concrete commands (orders)
        Command preparePizzaCommand = new PreparePizzaCommand(chef);
        Command servePastaCommand = new ServePastaCommand(chef);

        // Create invoker (waiter)
        Waiter waiter = new Waiter();

        // Set and execute commands
        waiter.setCommand(preparePizzaCommand);
        waiter.executeCommand();

        waiter.setCommand(servePastaCommand);
        waiter.executeCommand();
    }
}
----

== Design Considerations

When implementing the Command Pattern, consider the following design considerations:

* Separation of Concerns: The pattern helps in separating the sender of a request (Client) from the object that executes the request (Receiver). This separation promotes loose coupling and allows for more flexible and maintainable code.
* Scalability: The Command Pattern supports scalability by allowing new commands to be easily added without modifying existing client code. This makes it straightforward to extend the functionality of an application with minimal impact on existing components.
* Undo Operations: The pattern facilitates implementing undo functionality by storing the state of executed commands or providing an undo operation within the command itself. This feature enhances the application's usability and user experience.
* Command Composition: Commands can be composed of multiple smaller commands, enabling complex actions to be constructed from simpler ones. This composability enhances code reuse and promotes modular design.
* Performance Considerations: While the Command Pattern offers flexibility and decoupling, it may introduce overhead, especially in scenarios with a large number of commands or frequent command invocations. Careful consideration should be given to performance implications, and optimizations may be necessary in performance-critical applications.


== Conclusion
In conclusion, the Command Pattern is a powerful tool for decoupling the sender of a request from its receiver, promoting flexibility, scalability, and maintainability in software design. By encapsulating requests as objects, the pattern allows for parameterization of clients with different requests, queueing of requests, and support for undo operations. Its separation of concerns and support for composition enable developers to build complex systems while maintaining simplicity and modularity. When applied thoughtfully, the Command Pattern enhances code readability, extensibility, and robustness, making it a valuable addition to the design patterns toolkit.