
= Chapter 14: The Observer Pattern
:imagesdir: ../images/ch14_Observer

== Introduction

[cols="2", frame="none", grid="none"]
|===
|Imagine you're in a classroom where the teacher is like a news broadcaster, giving out information (or "news") to all the students. Now, in this classroom, some students are interested in math news, some in science news, and others might be interested in literature news. 

Each student who is interested in a particular type of news tells the teacher, "Hey, please let me know whenever there's news about my favorite subject!"

The Observer Pattern works a lot like this classroom scenario. In this pattern, the teacher acts as the "Subject," and the students are the "Observers." The Subject has important information or updates to share, and the Observers are interested in receiving updates about certain topics.
|image:observer_teacher_image.jpg[width=370, scale=50%]
|===


== Key Components

* _Subject_: The Subject is the class or object that holds the important information or updates. In the classroom analogy, the teacher represents the Subject who broadcasts news to the students.
* _Observer_: Observers are the classes or objects that are interested in receiving updates from the Subject. In the classroom scenario, the students represent the Observers who request to be notified whenever there's news about their favorite subject.

== UML Diagrams 
Next, we will explain the concept of the Observer design pattern using UML.

=== Class Diagram
image::ObserverPatternClassDiagram.png[title="The Observer Class Diagram"]
In this class diagram, let's interpret the Observer Pattern using the analogy of a teacher and students in a classroom. The "Subject" class represents the teacher who holds important information or updates. The teacher maintains a list of observers (students) interested in receiving updates. ConcreteObserverA and ConcreteObserverB represent individual students interested in updates. Both ConcreteObserverA and ConcreteObserverB implement the Observer interface, specifying the update method. The Subject class provides methods to attach and detach observers from its list and to notify all observers when there's new information available. Overall, this diagram illustrates how the teacher (Subject) manages a group of students (Observers) who are interested in receiving updates in a classroom setting.

=== Sequence Diagram
image::ObserverPatternSequenceDiagram.png[title="The Observer Sequence Diagram"]
In this sequence diagram, let's interpret the Observer Pattern using the analogy of a teacher and students in a classroom. The "Subject" represents the teacher who has important information or updates to share with the students. Initially, the teacher activates and attaches ObserverA and ObserverB, representing two students interested in receiving updates. When the teacher receives new information (setState(newState)), it activates itself to update its state. Then, it notifies ObserverA and ObserverB about the new state. Each observer, upon receiving the notification, activates itself to update its state accordingly. Overall, this sequence demonstrates how the teacher (Subject) broadcasts updates to interested students (Observers) in a classroom setting.

== Implementation Walkthrough

In this example, we'll implement the Observer Pattern in Java using the analogy of a teacher (Subject) and students (Observers) in a classroom. The teacher will broadcast updates to the students, and the students interested in receiving updates will be notified accordingly.

=== Student Interface

[source,java]
----
public interface Student {
    void receiveUpdate();
}
----

The `Student` interface defines the contract for all students (observers) interested in receiving updates. It specifies the `receiveUpdate()` method that each student must implement.

=== MathStudent and ScienceStudent Classes

[source,java]
----
public class MathStudent implements Student {
    public void receiveUpdate() {
        System.out.println("Math student received an update from the teacher.");
        // Logic for processing the update
    }
}

public class ScienceStudent implements Student {
    public void receiveUpdate() {
        System.out.println("Science student received an update from the teacher.");
        // Logic for processing the update
    }
}
----

The `MathStudent` and `ScienceStudent` classes represent individual students interested in receiving updates from the teacher. They implement the `Student` interface and provide their own logic for processing updates.

=== Teacher Class

[source,java]
----
import java.util.ArrayList;
import java.util.List;

public class Teacher {
    private List<Student> students = new ArrayList<>();

    public void addStudent(Student student) {
        students.add(student);
    }

    public void removeStudent(Student student) {
        students.remove(student);
    }

    public void notifyStudents() {
        for (Student student : students) {
            student.receiveUpdate();
        }
    }
}
----

The `Teacher` class represents the teacher who holds important information or updates. It maintains a list of students interested in receiving updates and provides methods to add, remove, and notify students.

=== Usage Example

[source,java]
----
public class Main {
    public static void main(String[] args) {
        Teacher teacher = new Teacher();
        
        // Students interested in updates
        Student mathStudent = new MathStudent();
        Student scienceStudent = new ScienceStudent();
        
        // Teacher adds students
        teacher.addStudent(mathStudent);
        teacher.addStudent(scienceStudent);
        
        // Teacher broadcasts an update
        teacher.notifyStudents();
    }
}
----

In this example, we create a `Teacher` object representing the teacher. We then create two `Student` objects representing students interested in updates. We add both students to the teacher, and then the teacher broadcasts an update. Each student receives the update and processes it accordingly.


== Design Considerations

The Observer Pattern offers several design considerations to keep in mind when implementing it:

* Loose Coupling: One of the main benefits of the Observer Pattern is that it promotes loose coupling between the subject and its observers. Observers are unaware of each other's existence and only depend on the subject. This allows for easier maintenance and modification of both the subject and observers independently.

* Flexibility: The pattern provides flexibility by allowing multiple observers to subscribe to changes in the subject. This means that new observers can be added or removed without modifying the subject, and vice versa. This flexibility makes the system more adaptable to changes in requirements or functionality.

* Extensibility: The Observer Pattern supports extensibility by enabling the addition of new observers or subjects without modifying existing code. This makes it easy to scale the system by adding new features or components without disrupting the existing architecture.

* Maintainability: By decoupling the subject and observers, the Observer Pattern improves maintainability by isolating changes to each component. Changes to the subject's state or behavior do not affect the observers, and vice versa. This makes it easier to understand, debug, and modify individual components of the system.

* Performance Considerations: While the Observer Pattern provides flexibility and maintainability, it can also introduce performance overhead, especially in scenarios with a large number of observers or frequent updates. Care should be taken to optimize performance by minimizing unnecessary notifications and ensuring efficient data handling.


== Conclusion

In conclusion, the Observer Pattern is a powerful design pattern that facilitates communication between objects in a loosely coupled and flexible manner. By decoupling the subject from its observers, it promotes extensibility, maintainability, and scalability in software systems. Observers can dynamically subscribe and unsubscribe to changes in the subject, enabling a reactive and event-driven architecture. While offering numerous benefits, such as flexibility and maintainability, it's essential to consider performance implications and optimize the implementation accordingly. Overall, the Observer Pattern is a valuable tool for designing systems where objects need to react to changes in state or behavior, making it a fundamental pattern in software engineering.