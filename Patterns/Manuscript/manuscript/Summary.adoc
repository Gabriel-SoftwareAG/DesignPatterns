|===
| Type | Name | What is it? | When to use it? | Example in Software Test Automation | Example in the Real World

| Creational
| Singleton
| Ensures a class only has one instance and provides a global point of access to it.
| When you need only one instance of a class throughout the system.
| Implementing a logger class to maintain a single log instance.
| The Library

| Creational
| Factory Method
| Defines an interface for creating an object, but allows subclasses to alter the type of objects that will be created.
| When a class cannot anticipate the class of objects it must create.
| Creating different types of web driver instances in Selenium.
| The Amusement Park

| Creational
| Abstract Factory
| Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
| When the system should be independent of how its objects are created, composed, and represented.
| Creating GUI testing frameworks that support different OSs and platforms.
| The Theme Amusement Park

| Creational
| Builder
| Separates the construction of a complex object from its representation so that the same construction process can create different representations.
| When the construction process must allow different representations for the object that's constructed.
| Building complex test data objects for various test cases.
| The Sandwich Bar

| Creational
| Prototype
| Creates new objects by copying an existing object, avoiding the need for repetitive initialization.
| When the cost of creating an instance of a given class is high.
| Cloning test cases with different input data for parallel execution.
| The Teddy Bear

| Structural
| Adapter
| Allows objects with incompatible interfaces to collaborate.
| When you want to use an existing class, and its interface doesn't match the one you need.
| Adapting third-party libraries for use in test frameworks.
| A Universal Adapter

| Structural
| Bridge
| Separates an object’s abstraction from its implementation so that the two can vary independently.
| When changes in the implementation of an abstraction should not impact clients.
| Creating a layer between test cases and test execution environments.
| 

| Structural
| Composite
| Composes objects into tree structures to represent part-whole hierarchies.
| When clients need to treat individual objects and compositions of objects uniformly.
| Representing test suites, test cases, and steps hierarchically.
| The Music Playlist

| Structural
| Decorator
| Attaches additional responsibilities to an object dynamically.
| When you need to add functionality to objects without modifying their code.
| Extending functionality of existing test case classes without altering them.
| 

| Structural
| Facade
| Provides a simplified interface to a larger body of code.
| When you want to provide a simple interface to a complex subsystem.
| Creating high-level APIs for interacting with testing tools.
| 

| Structural
| Flyweight
| Minimizes memory usage or computational expenses by sharing as much as possible with related objects.
| When the application uses a massive number of objects and needs to save resources.
| Storing frequently used test data or objects in a cache for reuse.
| The Party Balloons

| Structural
| Proxy
| Provides a surrogate or placeholder for another object to control access to it.
| When you need to control access to an object.
| Implementing lazy loading for test resources to improve performance.
| The Lawyer

| Behavioral
| Chain of Responsibility
| Passes requests along a chain of handlers, allowing multiple objects to have the chance to handle the request.
| When you want to give more than one object a chance to handle a request.
| Creating a chain of validation rules to validate test data.
| 

| Behavioral
| Command
| Encapsulates a request as an object, thereby allowing for parameterization of clients with queues, requests, and operations.
| When you want to parameterize objects with operations.
| Implementing a command pattern to execute test cases based on user input.
| The Restaurant Waiter

| Behavioral
| Interpreter
| Defines a grammar for interpreting language, and provides an interpreter for the language grammar.
| When you need to interpret sentences in a language and execute them.
| Building a domain-specific language for expressing test case scenarios.
| 

| Behavioral
| Iterator
| Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
| When you need to traverse a collection of objects without exposing its underlying representation.
| Iterating over test case collections for execution or validation.
| 

| Behavioral
| Mediator
| Defines an object that encapsulates how a set of objects interact.
| When you need to reduce chaotic dependencies between objects.
| Coordinating interactions between different test components in a framework.
| 

| Behavioral
| Memento
| Captures and externalizes an object’s internal state so that the object can be restored to this state later.
| When you need to capture the internal state of an object to restore it later.
| Saving the state of test execution in case of failure for later analysis.
| 

| Behavioral
| Observer
| Defines a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically.
| When you need to maintain consistency between related objects.
| Implementing listeners to detect and react to changes in test execution.
| The Broadcasting Teacher

| Behavioral
| State
| Allows an object to alter its behavior when its internal state changes.
| When an object’s behavior depends on its state, and it must change its behavior at runtime.
| Implementing different behaviors for test cases based on their execution status.
| 

| Behavioral
| Strategy
| Defines a family of algorithms, encapsulates each one, and makes them interchangeable.
| When you want to select an algorithm dynamically at runtime.
| Implementing various assertion strategies for test case validation.
| 

| Behavioral
| Template Method
| Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.
| When you want to allow subclasses to redefine certain steps of an algorithm.
| Defining a template for test case execution with customizable setup and teardown steps.
| 

| Behavioral
| Visitor
| Defines a new operation to a collection of objects without changing the objects themselves.
| When you want to perform operations on an object structure and keep the object classes separate.
| Implementing operations like logging, reporting, or data extraction on test objects.
| 
|===
