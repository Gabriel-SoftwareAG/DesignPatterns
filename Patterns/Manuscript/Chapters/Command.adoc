= Command Design Pattern

== Introduction

The Command Design Pattern is a behavioral design pattern that turns a request into a stand-alone object. This allows request parameters to be saved, queued, and executed at different times according to the application's needs. Imagine you're at a restaurant. You (the `Client`) give your order (`Command`) to a waiter (`Invoker`), who then delivers the order to the kitchen (`Receiver`). The kitchen prepares your meal and eventually, the waiter delivers the meal back to you. In this analogy, your order is encapsulated as a command and handled independently of the initial request.

image:../images/command_kitchen.jpg[]

== Key Concepts

The Command Pattern is built around several key concepts:

* _Command Interface_: Defines the command's execute method.
* _Concrete Command_: Implements the command interface and defines the binding between the receiver object and an action.
* _Client_: Creates a concrete command and sets its receiver.
* _Invoker_: Asks the command to carry out the request.
* _Receiver_: Knows how to perform the operations associated with carrying out a request.

== Diagram Placeholder

[NOTE]
====
// Diagram will be inserted here in the final document.
====

== Class Diagram Explained

The class diagram for the Command Design Pattern typically involves the following components:

* _Command_: An interface with a method `execute()`.
* _ConcreteCommand_: Classes that implement the Command interface and call a method on a Receiver.
* _Invoker_: Holds a command and at some point asks the command to execute a request by calling its `execute()` method.
* _Receiver_: The object that performs the actual action when the command's `execute()` method is called.
* _Client_: Creates a ConcreteCommand object and sets its receiver.

== Implementation Walkthrough

Let's implement a simple Command Pattern example in Java:

[source,java]
----
// Command Interface
interface Command {
    void execute();
}

// Receiver
class Light {
    public void turnOn() {
        System.out.println("Light is ON");
    }

    public void turnOff() {
        System.out.println("Light is OFF");
    }
}

// ConcreteCommand
class TurnOnLightCommand implements Command {
    private Light light;

    public TurnOnLightCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOn();
    }
}

// Invoker
class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}

// Client
public class CommandPatternDemo {
    public static void main(String[] args) {
        Light light = new Light();
        Command switchOn = new TurnOnLightCommand(light);

        RemoteControl remote = new RemoteControl();
        remote.setCommand(switchOn);
        remote.pressButton();
    }
}
----

In this example, `Light` acts as the Receiver that knows how to perform operations (turning on/off the light). `TurnOnLightCommand` is a ConcreteCommand that implements the `execute` method by invoking the corresponding operation on the `Light`. The `RemoteControl` acts as an Invoker, and `CommandPatternDemo` is the Client that creates the command and sets its receiver.

== Real-life Example for a Scenario: E-commerce Website Testing

Consider an e-commerce website where a series of automated tests need to be performed: adding items to the cart, applying discounts, and checking out. Each of these actions can be encapsulated as a command, allowing tests to be executed in isolation or as part of test suites with different configurations.

== Design Considerations

When implementing the Command Pattern, consider:

* Command aggregation for macro commands.
* Extending Command capabilities for undo functionality.
* Decoupling Invokers from ConcreteCommands to enhance flexibility.

== Conclusions

The Command Design Pattern offers a powerful way to decouple the requester of an action from the object that actually performs the action. This pattern provides flexibility in the design of command-driven applications, including queueing requests, undo/redo operations, and logging changes.
